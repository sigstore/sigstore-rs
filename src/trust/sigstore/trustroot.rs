#![allow(dead_code)]

// HACK(jl): protobuf-specs schemas are currently compiled for direct dependencies of the Bundle schema.
// See note https://github.com/sigstore/protobuf-specs/blob/main/gen/pb-rust/src/lib.rs#L1-L23
// HACK(ap): We should probably use definitions from sigstore-protobuf-specs, but
// the autogenerated definitions are unergonomic. Declare it locally here.

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_with::base64::Base64;

use serde_with::serde_as;

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[allow(non_camel_case_types)]
/// Only a subset of the secure hash standard algorithms are supported.
/// See <https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf> for more
/// details.
/// UNSPECIFIED SHOULD not be used, primary reason for inclusion is to force
/// any proto JSON serialization to emit the used hash algorithm, as default
/// option is to *omit* the default value of an enum (which is the first
/// value, represented by '0'.
pub(crate) enum HashAlgorithm {
    HASH_ALGORITHM_UNSPECIFIED = 0,
    SHA2_256 = 1,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[allow(non_camel_case_types)]
/// Details of a specific public key, capturing the the key encoding method,
/// and signature algorithm.
/// To avoid the possibility of contradicting formats such as PKCS1 with
/// ED25519 the valid permutations are listed as a linear set instead of a
/// cartesian set (i.e one combined variable instead of two, one for encoding
/// and one for the signature algorithm).
pub(crate) enum PublicKeyDetails {
    PUBLIC_KEY_DETAILS_UNSPECIFIED = 0,
    // RSA
    PKCS1_RSA_PKCS1V5 = 1, // See RFC8017
    PKCS1_RSA_PSS = 2,     // See RFC8017
    PKIX_RSA_PKCS1V5 = 3,
    PKIX_RSA_PSS = 4,
    // ECDSA
    PKIX_ECDSA_P256_SHA_256 = 5,      // See NIST FIPS 186-4
    PKIX_ECDSA_P256_HMAC_SHA_256 = 6, // See RFC6979
    // Ed 25519
    PKIX_ED25519 = 7, // See RFC8032
}

#[serde_as]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// LogId captures the identity of a transparency log.
pub(crate) struct LogId {
    #[serde_as(as = "Base64")]
    pub key_id: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// The time range is closed and includes both the start and end times,
/// (i.e., [start, end]).
/// End is optional to be able to capture a period that has started but
/// has no known end.
pub(crate) struct TimeRange {
    pub start: DateTime<Utc>,
    pub end: Option<DateTime<Utc>>,
}

#[serde_as]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct PublicKey {
    #[serde_as(as = "Option<Base64>")]
    pub raw_bytes: Option<Vec<u8>>,
    pub key_details: PublicKeyDetails,
    pub valid_for: Option<TimeRange>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct DistinguishedName {
    pub organization: String,
    pub common_name: String,
}

#[serde_as]
#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
pub(crate) struct X509Certificate {
    #[serde_as(as = "Base64")]
    pub raw_bytes: Vec<u8>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// A chain of X.509 certificates.
pub(crate) struct X509CertificateChain {
    pub certificates: Vec<X509Certificate>,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// TransparencyLogInstance describes the immutable parameters from a
/// transparency log.
/// See https://www.rfc-editor.org/rfc/rfc9162.html#name-log-parameters
/// for more details.
/// The included parameters are the minimal set required to identify a log,
/// and verify an inclusion proof/promise.
pub(crate) struct TransparencyLogInstance {
    pub base_url: String,
    pub hash_algorithm: HashAlgorithm,
    pub public_key: PublicKey,
    pub log_id: LogId,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// CertificateAuthority enlists the information required to identify which
/// CA to use and perform signature verification.
pub(crate) struct CertificateAuthority {
    pub subject: DistinguishedName,
    pub uri: Option<String>,
    pub cert_chain: X509CertificateChain,
    pub valid_for: TimeRange,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(rename_all = "camelCase")]
/// TrustedRoot describes the client's complete set of trusted entities.
/// How the TrustedRoot is populated is not specified, but can be a
/// combination of many sources such as TUF repositories, files on disk etc.
///
/// The TrustedRoot is not meant to be used for any artifact verification, only
/// to capture the complete/global set of trusted verification materials.
/// When verifying an artifact, based on the artifact and policies, a selection
/// of keys/authorities are expected to be extracted and provided to the
/// verification function. This way the set of keys/authorities can be kept to
/// a minimal set by the policy to gain better control over what signatures
/// that are allowed.
///
/// The embedded transparency logs, CT logs, CAs and TSAs MUST include any
/// previously used instance -- otherwise signatures made in the past cannot
/// be verified.
/// The currently used instances MUST NOT have their 'end' timestamp set in
/// their 'valid_for' attribute for easy identification.
/// All the listed instances SHOULD be sorted by the 'valid_for' in ascending
/// order, that is, the oldest instance first and the current instance last.
pub(crate) struct TrustedRoot {
    pub media_type: String,
    pub tlogs: Vec<TransparencyLogInstance>,
    pub certificate_authorities: Vec<CertificateAuthority>,
    pub ctlogs: Vec<TransparencyLogInstance>,
    pub timestamp_authorities: Vec<CertificateAuthority>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn tuf_serde_as_base64() {
        let data = X509Certificate {
            raw_bytes: b"Hello World".to_vec(), // NOTE(jl): value not representative
        };
        let json = serde_json::json!({"rawBytes": "SGVsbG8gV29ybGQ=",});

        assert_eq!(json, serde_json::to_value(&data).unwrap());
        assert_eq!(data, serde_json::from_value(json).unwrap());
    }

    #[test]
    fn tuf_serde_as_nested_structure_base64() {
        let data = PublicKey {
            raw_bytes: Some(b"Hello World".to_vec()),
            key_details: PublicKeyDetails::PKIX_ED25519,
            valid_for: Some(TimeRange {
                start: DateTime::from_timestamp(1_500_000_000, 0).unwrap(),
                end: None,
            }),
        };
        let json = serde_json::json!({
            "rawBytes": "SGVsbG8gV29ybGQ=",
            "keyDetails": "PKIX_ED25519",
            "validFor": {
                "start": "2017-07-14T02:40:00Z",
                "end": None::<DateTime<Utc>>
            }
        });

        assert_eq!(json, serde_json::to_value(&data).unwrap());
        assert_eq!(data, serde_json::from_value(json).unwrap());
    }
}
