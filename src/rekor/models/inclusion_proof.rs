/*
 * Rekor
 *
 * Rekor is a cryptographically secure, immutable transparency log for signed software releases.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::crypto::merkle::{
    hex_to_hash_output, MerkleProofVerifier, Rfc6269Default, Rfc6269HasherTrait,
};
use crate::crypto::CosignVerificationKey;
use crate::errors::SigstoreError;
use crate::errors::SigstoreError::{InclusionProofError, UnexpectedError};
use crate::rekor::models::checkpoint::Checkpoint;
use crate::rekor::TreeSize;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize)]
pub struct InclusionProof {
    /// The index of the entry in the transparency log
    #[serde(rename = "logIndex")]
    pub log_index: i64,
    /// The hash value stored at the root of the merkle tree at the time the proof was generated
    #[serde(rename = "rootHash")]
    pub root_hash: String,
    /// The size of the merkle tree at the time the inclusion proof was generated
    #[serde(rename = "treeSize")]
    pub tree_size: TreeSize,
    /// A list of hashes required to compute the inclusion proof, sorted in order from leaf to root
    #[serde(rename = "hashes")]
    pub hashes: Vec<String>,
    pub checkpoint: Option<Checkpoint>,
}

impl InclusionProof {
    pub fn new(
        log_index: i64,
        root_hash: String,
        tree_size: TreeSize,
        hashes: Vec<String>,
        checkpoint: Option<Checkpoint>,
    ) -> InclusionProof {
        InclusionProof {
            log_index,
            root_hash,
            tree_size,
            hashes,
            checkpoint,
        }
    }

    /// Verify that the canonically encoded `entry` is included in the log,
    /// and the included checkpoint was signed by the log.
    pub fn verify(
        &self,
        entry: &[u8],
        rekor_key: &CosignVerificationKey,
    ) -> Result<(), SigstoreError> {
        // enforce that there is a checkpoint
        let checkpoint = self.checkpoint.as_ref().ok_or(UnexpectedError(
            "inclusion proof misses checkpoint".to_string(),
        ))?;

        // verify the checkpoint signature
        checkpoint.verify_signature(rekor_key)?;

        let entry_hash = Rfc6269Default::hash_leaf(entry);

        // decode hashes from hex and convert them to the required data structure
        // immediately return an error when conversion fails
        let proof_hashes = self
            .hashes
            .iter()
            .map(hex_to_hash_output)
            .collect::<Result<Vec<_>, _>>()?;

        let root_hash = hex_to_hash_output(&self.root_hash)?;

        // check if the inclusion and checkpoint match
        checkpoint.is_valid_for_proof(&root_hash, self.tree_size as u64)?;

        Rfc6269Default::verify_inclusion(
            self.log_index as u64,
            &entry_hash,
            self.tree_size as u64,
            &proof_hashes,
            &root_hash,
        )
        .map_err(InclusionProofError)
    }
}
