/*
 * Rekor
 *
 * Rekor is a cryptographically secure, immutable transparency log for signed software releases.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::crypto::merkle::hex_to_hash_output;
use crate::crypto::CosignVerificationKey;
use crate::errors::SigstoreError;
use crate::rekor::models::checkpoint::Checkpoint;
use crate::rekor::models::ConsistencyProof;
use crate::rekor::TreeSize;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub struct LogInfo {
    /// The current hash value stored at the root of the merkle tree
    #[serde(rename = "rootHash")]
    pub root_hash: String,
    /// The current number of nodes in the merkle tree
    #[serde(rename = "treeSize")]
    pub tree_size: TreeSize,
    /// The current signed tree head
    #[serde(rename = "signedTreeHead")]
    pub signed_tree_head: Checkpoint,
    /// The current treeID
    #[serde(rename = "treeID")]
    pub tree_id: Option<String>,
    #[serde(rename = "inactiveShards", skip_serializing_if = "Option::is_none")]
    pub inactive_shards: Option<Vec<crate::rekor::models::InactiveShardLogInfo>>,
}

impl LogInfo {
    pub fn new(root_hash: String, tree_size: TreeSize, signed_tree_head: Checkpoint) -> LogInfo {
        LogInfo {
            root_hash,
            tree_size,
            signed_tree_head,
            tree_id: None,
            inactive_shards: None,
        }
    }
    /// Verify the consistency of the proof provided by the log.
    ///
    /// Example:
    /// ```rust
    /// use sigstore::crypto::{CosignVerificationKey, SigningScheme};
    /// use sigstore::rekor::apis::configuration::Configuration;
    /// use sigstore::rekor::apis::pubkey_api::get_public_key;
    /// use sigstore::rekor::apis::tlog_api::{get_log_info, get_log_proof};
    ///
    /// #[tokio::main]
    /// async fn main() {
    ///     let rekor_config = Configuration::default();
    ///
    ///     // Important: in practice obtain the rekor key via TUF repo or another secure channel!
    ///     let rekor_key = get_public_key(&rekor_config, None)
    ///         .await
    ///         .expect("failed to fetch pubkey from remote log");
    ///     let rekor_key =  CosignVerificationKey::from_pem(
    ///         rekor_key.as_bytes(),
    ///         &SigningScheme::ECDSA_P256_SHA256_ASN1,
    ///     ).expect("failed to parse rekor key");
    ///     // fetch log info twice and run consistency proof
    ///     let log_info1 = get_log_info(&rekor_config)
    ///         .await
    ///         .expect("failed to fetch data from remote");
    ///     let log_info2 = get_log_info(&rekor_config)
    ///         .await
    ///         .expect("failed to fetch data from remote");
    ///
    ///     // get a proof using log_info1 as the previous tree state
    ///     let proof = get_log_proof(
    ///         &rekor_config,
    ///         log_info2.tree_size as _,
    ///         Some(&log_info1.tree_size.to_string()),
    ///         None,
    ///     )
    ///     .await
    ///     .expect("failed to fetch data from remote");
    ///     
    ///     // verify proof for the new log info
    ///     log_info2
    ///         .verify_consistency(log_info1.tree_size, &log_info1.root_hash, &proof, &rekor_key)
    ///         .expect("failed to verify log consistency");
    /// }
    ///
    /// ```
    pub fn verify_consistency(
        &self,
        old_size: u64,
        old_root: &str,
        consistency_proof: &ConsistencyProof,
        rekor_key: &CosignVerificationKey,
    ) -> Result<(), SigstoreError> {
        // verify checkpoint is signed by log
        self.signed_tree_head.verify_signature(rekor_key)?;

        self.signed_tree_head
            .is_valid_for_proof(&hex_to_hash_output(&self.root_hash)?, self.tree_size)?;
        consistency_proof.verify(old_size, old_root, self.tree_size as _)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use crate::{
        crypto::{CosignVerificationKey, SigningScheme},
        rekor::models::ConsistencyProof,
    };

    use super::LogInfo;
    const LOG_INFO_OLD: &str = r#"{
        "inactiveShards": [
          {
            "rootHash": "ed4cb79f98642c7cd7626f8307d8fee48e04991dc4e827611884f131e53221ba",
            "signedTreeHead": "rekor.sigstage.dev - 8959784741570461564\n461\n7Uy3n5hkLHzXYm+DB9j+5I4EmR3E6CdhGITxMeUyIbo=\n\n— rekor.sigstage.dev 0y8wozBFAiBeSutKae/1zsGfMgCstDexSktqVfYgAKYaFNsBqYQ3cAIhAOewsY+B/oXGOILSBv3wduhlyn4wNmV3v1eRg3LOwHDi\n",
            "treeID": "8959784741570461564",
            "treeSize": 461
          },
          {
            "rootHash": "effa4fa4575f72829016a64e584441203de533212f9470d63a56d1992e73465d",
            "signedTreeHead": "rekor.sigstage.dev - 108574341321668964\n14358\n7/pPpFdfcoKQFqZOWERBID3lMyEvlHDWOlbRmS5zRl0=\n\n— rekor.sigstage.dev 0y8wozBFAiBJlYY/wJQw6hW3LzziTAp7SXjc7MfghJ31tiydO1MvrAIhAPCX7LQ5jUNOssRDFJPXX3DdQjdan+8UGrKzGgfayV0c\n",
            "treeID": "108574341321668964",
            "treeSize": 14358
          },
          {
            "rootHash": "ae6af751ddcfffc1b77386692d7eaa9b105c191cb613fad3e718183513b956f1",
            "signedTreeHead": "rekor.sigstage.dev - 8050909264565447525\n31667593\nrmr3Ud3P/8G3c4ZpLX6qmxBcGRy2E/rT5xgYNRO5VvE=\n\n— rekor.sigstage.dev 0y8wozBFAiEA6yozMl9lFn21m5mQHCJUyEiI3HOOuM5sIeVt/MU2MQMCIBDhFtWjwPKIjFSr/liQ8LY7K6LHQRvtzkoIrsWZ/c9a\n",
            "treeID": "8050909264565447525",
            "treeSize": 31667593
          }
        ],
        "rootHash": "e222aa53db49893334fb5a878ead1bf8b9f8f3c02ccfc0ae687f28256bd74907",
        "signedTreeHead": "rekor.sigstage.dev - 8202293616175992157\n1352760\n4iKqU9tJiTM0+1qHjq0b+Ln488Asz8CuaH8oJWvXSQc=\n\n— rekor.sigstage.dev 0y8wozBFAiEAnIjdHAH9uhqBrRNBA4bMaKR30H6qdzW4TAsdB0/KP0ICIDjK9VeE+9dWXSAm/B0aPkhO7pJMLmKPjo9btFD9ZvEs\n",
        "treeID": "8202293616175992157",
        "treeSize": 1352760
      }"#;
    const LOG_INFO_NEW: &str = r#"
        {
            "inactiveShards": [
            {
                "rootHash": "ed4cb79f98642c7cd7626f8307d8fee48e04991dc4e827611884f131e53221ba",
                "signedTreeHead": "rekor.sigstage.dev - 8959784741570461564\n461\n7Uy3n5hkLHzXYm+DB9j+5I4EmR3E6CdhGITxMeUyIbo=\n\n— rekor.sigstage.dev 0y8wozBFAiEAvtvC/roj8MxqTqvyHaq5pVHQ4eWJwNb/BpMNGLrjPdYCIB5rWm8b1FCsnVUty27Gyvod3PB9MgG6ar24XDYrNSau\n",
                "treeID": "8959784741570461564",
                "treeSize": 461
            },
            {
                "rootHash": "effa4fa4575f72829016a64e584441203de533212f9470d63a56d1992e73465d",
                "signedTreeHead": "rekor.sigstage.dev - 108574341321668964\n14358\n7/pPpFdfcoKQFqZOWERBID3lMyEvlHDWOlbRmS5zRl0=\n\n— rekor.sigstage.dev 0y8wozBFAiEA5zsLKvJeAuSc61IxVqNKnyVA0FIOZFck/cQl1BoYj0kCICMOJUulfDbukn5ApybPKUJ20nsFQ0P/54ku3/bl0Thq\n",
                "treeID": "108574341321668964",
                "treeSize": 14358
            },
            {
                "rootHash": "ae6af751ddcfffc1b77386692d7eaa9b105c191cb613fad3e718183513b956f1",
                "signedTreeHead": "rekor.sigstage.dev - 8050909264565447525\n31667593\nrmr3Ud3P/8G3c4ZpLX6qmxBcGRy2E/rT5xgYNRO5VvE=\n\n— rekor.sigstage.dev 0y8wozBEAiBok3nxMEarLtLkNJFCq+4A3r1givc2YZqO48quIGEOrgIgUGJwm2+yr59SH/Vmf7+XxPY/mMIuyXlP6OXDdnHglF0=\n",
                "treeID": "8050909264565447525",
                "treeSize": 31667593
            }
            ],
            "rootHash": "c7d98fcf73e06fb3b7a6c02648dee52567a4b7b6db1dae31ec723283b379c782",
            "signedTreeHead": "rekor.sigstage.dev - 8202293616175992157\n1352764\nx9mPz3Pgb7O3psAmSN7lJWekt7bbHa4x7HIyg7N5x4I=\n\n— rekor.sigstage.dev 0y8wozBGAiEAiU8vSPj7yujJ2R6ES8t2AXJG+uezCj5Th7Dp6U5kBU0CIQCDObTWELwMeAa0u1VndfB+WvXEXKtYTNm5QXzK7d7xhA==\n",
            "treeID": "8202293616175992157",
            "treeSize": 1352764
        }"#;
    const LOG_PROOF: &str = r#"
        {
            "hashes": [
                "5a0948dede3e930b8f4e54623e9dddc02d8d1f8e7207aa2ef654581696dbd02b",
                "a231a8bf92e79b70d99762dc5e97b8aabd7d7e345af3ecd54806a67a856e28fd",
                "1da069f21926d9a6c71f5f53e3802f9a319592aaec38a26cca7000756013a8b0",
                "de67dba818dcb59afa1eaf82f404ea3d60b9284fefcd48091cc392eeb85139e0",
                "722774afdc8d9f7600104ebf18c9eed3f293990b516b5cc582455580182e5228",
                "3cffd1e781089b1863981adefbc568102b38020a978318d73d90e3baa25893f6",
                "26104de6f96047f3832e4fa21aef89e86de2b26d53f7f88bf652cbcdfcaf8fb7",
                "c0bb4187448a423c7bb2a4e16ccee560ca47911049be666e335f28c5cc28f604",
                "f95530163ba56a3da36ccfb774bf971c8e5197ebfb55b0a2f76dfa20efdf6a60",
                "b4ee4fbb14937fa10fb77eda8f17492af7167311952c54a3c948263a70fa4d16",
                "14873f5f2d7ddbaa9c35cae8e38a75d86771103593ff587009503011d0fd4656",
                "3e879a6680719f5f20080d96af7054eac1f7e6c73d08cf7242e1d2ed1d0baa75",
                "3936c8b8d984010658bcd36b2e7bb812964fb04de546da6e4be5877d6d30b244",
                "832595ab7e4069d2b4439048e1844ae610ad1b739271a80b8e2eaf90daf2db0e",
                "404ec07c1283ca96add90addbdb4e61cc46e842878b48abab7d06cdf2cd41431",
                "53766be84290a00a98d2f412fbdafdcf9b76c25b2558a6824c4ed0942d2608ee",
                "af298842ed85c9133527e4806ecf131eba8cda15b557ae8aa7d0b23579226037",
                "3be14d5554e638fc70239826191844aa65251487eb50704a91628aeb200b77ba",
                "897eece5297ade68dbb8771d2fb8f0745f09510a5c10b751df2aea9c831f748d",
                "e9d4090a317dc9e584a04d2268a1b808ac1cf092021fa29a7f879fdffa9bf271",
                "42051abed257700e92e99263172d12ff2ff23c7fb6f6e5d0bb141723a15c346c"
            ],
            "rootHash": "df83e27afbe9fa6d04f417879882f9c29a6c4b2d677a01c53f5189dbd3290b31"
        }"#;

    /// Pubkey for `rekor.sigstage.dev`.
    const REKOR_STAGING_KEY_PEM: &str = r#"
    -----BEGIN PUBLIC KEY-----
    MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEDODRU688UYGuy54mNUlaEBiQdTE9
    nYLr0lg6RXowI/QV/RE1azBn4Eg5/2uTOMbhB1/gfcHzijzFi9Tk+g1Prg==
    -----END PUBLIC KEY-----
"#;
    #[test]
    fn test_consistency() {
        let rekor_key = CosignVerificationKey::from_pem(
            REKOR_STAGING_KEY_PEM.as_bytes(),
            &SigningScheme::ECDSA_P256_SHA256_ASN1,
        )
        .expect("failed to parse Rekor key");
        let log_info_old: LogInfo =
            serde_json::from_str(LOG_INFO_OLD).expect("failed to deserialize log info test data");
        let log_info_new: LogInfo =
            serde_json::from_str(LOG_INFO_NEW).expect("failed to deserialize log info test data");
        let consistency_proof: ConsistencyProof =
            serde_json::from_str(LOG_PROOF).expect("failed to deserialize log proof data");
        log_info_new
            .verify_consistency(
                log_info_old.tree_size,
                &log_info_old.root_hash,
                &consistency_proof,
                &rekor_key,
            )
            .expect("failed to accept valid inclusion proof");
    }
}
