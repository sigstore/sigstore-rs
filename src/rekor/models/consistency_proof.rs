/*
 * Rekor
 *
 * Rekor is a cryptographically secure, immutable transparency log for signed software releases.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::crypto::merkle::hex_to_hash_output;
use crate::crypto::merkle::{MerkleProofVerifier, Rfc6269Default};
use crate::errors::SigstoreError;
use crate::errors::SigstoreError::ConsistencyProofError;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, Eq, Default, Serialize, Deserialize)]
pub struct ConsistencyProof {
    /// The hash value stored at the root of the merkle tree at the time the proof was generated
    #[serde(rename = "rootHash")]
    pub root_hash: String,
    #[serde(rename = "hashes")]
    pub hashes: Vec<String>,
}

impl ConsistencyProof {
    pub fn new(root_hash: String, hashes: Vec<String>) -> ConsistencyProof {
        ConsistencyProof { root_hash, hashes }
    }

    /// Verify this consistency proof against the given parameters.
    pub fn verify(
        &self,
        old_size: u64,
        old_root: &str,
        new_size: u64,
    ) -> Result<(), SigstoreError> {
        // decode hashes from hex and convert them to the required data structure
        // immediately return an error when conversion fails
        let proof_hashes = self
            .hashes
            .iter()
            .map(hex_to_hash_output)
            .collect::<Result<Vec<_>, _>>()?;

        let old_root = hex_to_hash_output(old_root)?;
        let new_root = hex_to_hash_output(&self.root_hash)?;

        Rfc6269Default::verify_consistency(old_size, new_size, &proof_hashes, &old_root, &new_root)
            .map_err(ConsistencyProofError)
    }
}
